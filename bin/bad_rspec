#!/bin/sh
hash ack 2>&- || { echo >&2 "I require ack but it's not installed.  Aborting."; exit 1; }
hash perl 2>&- || { echo >&2 "I require perl but it's not installed.  Aborting."; exit 1; }

# TODO: make this tell you when it found bad rspec code, what the code is, and prompt the user
# with options to (r)eplace, r(e)view, (o)verwrite, (i)gnore
# check_shoulds() {
  # ack "empty\?.should be_true"
  # ack "empty\?.should be_false"
  # ack "should == "
  # ack "should_not == "
  # ack "should != "
# }

get_user_action() {
  echo "\tWhat would you like to do to this issue?\n\t\t(r)eplace, r(e)view, (i)gnore"
  read -n 1 answer
  case $answer in
    i)
      ;;
    r)
      ;;
    e)
      ;;
    *)
      echo "\tIncorrect answer"
      get_user_action
      ;;
  esac
}

check_bad_eq_eq(){
  answer="i"
  should_eq_eq=`ack "should == "`
  if [ -n "$should_eq_eq" ]; then
    echo "\tYou're using \"should ==\" instead of \"should eq()\""
    echo "\tThe only problem with this is that it doesn't conform to a good style of test writing"
    while :
    do
      get_user_action
      case $answer in
        i)
          break
          ;;
        r)
          find . -name '*.rb' -exec perl -i '' -e 's/should ==([\w\W]+)/should eq\($1\)/g' {} \;
          break
          ;;
        e)
          echo "$should_eq_eq"
          ;;
      esac
    done
  fi
}

check_bad_should_not(){
  answer="i"
  echo "answer is $answer"
}

check_bad_eq_eq
check_bad_should_not

# TODO: check for the use of instance variables and warn against it, explaining
# why the use of 'let' helpers is a better way

# TODO: check for expect { ..... }.should
# We should be using }.to instead

# TODO: look for things like .count.should

# TODO: look for "is_a?(Object).should be_true"
