# ~/.hashrc
# vim:set ft=sh sw=2 sts=2:

[ -e "$DEV_DIR" ] || DEV_DIR="$HOME/Development"
export DEV_DIR

for dir in /opt/local/bin /usr/local/bin "$HOME/bin"; do
  case "$PATH:" in
    *:"$dir":*) PATH="`echo "$PATH"|sed -e "s#:$dir##"`" ;;
  esac
  [ ! -d "$dir" ] || PATH="$dir:$PATH"
done
for dir in /usr/local/sbin /opt/local/sbin; do
  case ":$PATH:" in
    *:"$dir":*) ;;
    *) [ ! -d "$dir" ] || PATH="$PATH:$dir" ;;
  esac
done

hcd() {
  cd "$DEV_DIR/$1"
}

pair() {
  local name email args initials author ret
  name=""
  email="dev"
  if [ -n "$ZSH_VERSION" ]; then
    eval 'args=(${(i)@})'
  else
    args="`for arg in "$@"; do echo "x$arg"|sed -e 's/^x//'|tr ' ' _; done|sort -f`"
  fi
  for arg in $args; do
    initials=
    author=
    case "x$arg" in
      x-h)
      echo 'pair person1 person2'
      echo 'pair person1 guest1="Real Name"'
      echo 'pair -u # go solo'
      echo 'pair    # status'
      return 1
      ;;
      x-e) ret=email;    continue ;;
      x-n) ret=name;     continue ;;
      x-f) ret=file;     continue ;;
      x-c) ret=commit;   continue ;;
      x-s) ret=setenv;   continue ;;
      x-u) ret=unsetenv; continue ;;
      x-w) echo "-w is now the default" >&2; continue ;;
      x-*) echo "Unknown option $arg" >&2; return 1 ;;
      x*=*)
      initials="`echo "$arg"|sed -e s/=.*//`"
      author="`echo "$arg"|sed -e s/[^=]*=//|tr _ ' '`"
      ;;
      [^-]*)
      initials="`echo "$arg"|tr a-z A-Z`"
      eval "author=\"\$DEV_AUTHOR_$initials\""
      ;;
    esac
    if [ -z "$author" ]; then
      echo "Invalid id $arg" >&2
      return 1
    fi
    name="$name and $author"
    email="$email+`echo "$initials"|tr A-Z a-z`"
  done
  name="`echo $name|sed -e 's/^ *and *//'`"
  email="$email@hashrocket.com"
  case "$ret" in
    unsetenv) unset GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL
    rm -f "$HOME/.pairrc"
    ;;
    email) echo "$email" ;;
    name)  echo "$name" ;;
    file) git config user.name "$name" && git config user.email "$email" ;;
    commit)
    (
    if [ "" = "$name" ]; then
      unset GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL
    else
      export GIT_AUTHOR_NAME="$name" GIT_AUTHOR_EMAIL="$email"
    fi
    git commit
    ) ;;
    *)
    if [ "" = "$name" ]; then
      echo "$GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL>"
    else
      export GIT_AUTHOR_NAME="$name" GIT_AUTHOR_EMAIL="$email"
      echo "$GIT_AUTHOR_NAME <$GIT_AUTHOR_EMAIL>"
      rm -f "$HOME/.pairrc"
      echo "export GIT_AUTHOR_NAME=\"$GIT_AUTHOR_NAME\"" > "$HOME/.pairrc"
      echo "export GIT_AUTHOR_EMAIL=\"$GIT_AUTHOR_EMAIL\"" >> "$HOME/.pairrc"
      echo pair >> "$HOME/.pairrc"
    fi ;;
  esac
}
[ -n "$GIT_AUTHOR_EMAIL" -o ! -f "$HOME/.pairrc" -o -z "$PS1" ] || . "$HOME/.pairrc"

git() {
  [ -f "$HOME/.hitch_export_authors" ] && . "$HOME/.hitch_export_authors"
  [ -f "$HOME/.pairrc" ] && . "$HOME/.pairrc" >/dev/null
  command git "$@"
}

# This might actually be useful for cloning all projects onto our local machines. Need to modify it though
# hclone() {
  # local url basename example new
  # if [ x-f = "x$1" ]; then
    # shift
    # rm -rf "$DEV_DIR/`basename $1 .git`"
  # fi
  # basename="`basename $1 .git`"
  # if [ ! -d "$DEV_DIR/$basename" ]; then
    # new=1
    # case "$1" in
      # *:*) url="$1" ;;
      # */*) url="git@github.com:$1.git" ;;
      # *)   url="git@github.com:hashrocket/$1.git" ;;
    # esac
    # git clone "$url" "$DEV_DIR/$basename" || return 1
    # for example in "$DEV_DIR/$basename"/config/*.example.yml; do
      # cp "$example" "${example%.example.yml}.yml"
    # done 2>/dev/null
    # if [ -f "$DEV_DIR/$basename/.rvmrc" ] && command -v __rvm_trust_rvmrc >/dev/null; then
      # __rvm_trust_rvmrc "$DEV_DIR/$basename/.rvmrc"
    # fi
  # fi
  # hcd "$basename"
  # if [ ! -f .git/hooks/post-rewrite ]; then
    # cat > .git/hooks/post-rewrite <<EOS
# !/bin/sh

# GIT_DIR="\$(dirname "\$(dirname "\$0")")"
# export GIT_DIR

# case "\$1" in
  # rebase) exec "\$GIT_DIR/hooks/post-merge" 0 rebase ;;
# esac
# EOS
  # fi
  # if [ ! -f .git/hooks/pre-commit ]; then
    # echo '#!/bin/sh' > .git/hooks/pre-commit
    # echo 'git diff --exit-code --cached -- Gemfile Gemfile.lock >/dev/null || bundle check' >> .git/hooks/pre-commit
  # fi
  # if [ ! -f .git/hooks/ctags ]; then
    # echo '#!/bin/sh' > .git/hooks/ctags
    # echo 'rm -f .git/tags' >> .git/hooks/ctags
    # echo 'ctags --tag-relative -f .git/tags --exclude=.git --languages=-javascript,sql -R' >> .git/hooks/ctags
    # chmod +x .git/hooks/ctags
    # for basename in post-checkout post-commit post-merge; do
      # echo '#!/bin/sh' > .git/hooks/$basename
      # echo '$GIT_DIR/hooks/ctags >/dev/null 2>&1 &' >> .git/hooks/$basename
      # chmod +x .git/hooks/$basename
    # done
    # .git/hooks/ctags
  # fi
  # if [ ! -f .git/hooks/bundle ]; then
    # cat > .git/hooks/bundle <<EOS
# !/bin/sh
# unset GIT_DIR
# if [ -f Gemfile ] && command -v bundle >/dev/null; then
  # echo 'Bundling...'
  # bundle | grep -v '^Using ' | grep -v ' is complete'
  # true
# fi
# EOS
    # chmod +x .git/hooks/bundle
    # echo "if git diff --name-only \$1 \$2 | egrep -q '^Gemfile|\\.gemspec\$'; then" >> .git/hooks/post-checkout
    # echo "  \$GIT_DIR/hooks/bundle" >> .git/hooks/post-checkout
    # echo "fi" >> .git/hooks/post-checkout
    # [ -z "$new" ] || .git/hooks/bundle
  # fi
  # if [ -n "$new" -a -x script/setup ]; then
    # script/setup
  # fi
# }

# Tab completion
if [ -n "$BASH_VERSION" ]; then
  _hcd()
  {
    local cur projects

    [ -r "$DEV_DIR" ] || return 0

    eval 'COMPREPLY=()'
    cur=${COMP_WORDS[COMP_CWORD]}
    projects=$(\ls "$DEV_DIR")

    if [ $COMP_CWORD -eq 1 ]; then
      eval 'COMPREPLY=( $(compgen -o filenames -W "$projects" $cur) )'
    fi

    return 0
  }
  complete -F _hcd hcd hclone
elif [ -n "$ZSH_VERSION" ]; then
  #compdef '_files -W "$DEV_DIR"' hcd hclone
  compctl -/ -W "$DEV_DIR" hcd hclone
fi

rails_root() {
  (
  dir=${1:-$(pwd)}
  i=0
  while [ "/" != "$dir" -a "$i" -ne 16 ]; do
    if [ -f "$dir/config/environment.rb" ]; then
      echo "$dir"
      return 0
    fi
    dir="$(dirname "$dir")"
    i=$(expr $i + 1)
  done
  return 1
  )
}

stc() {
  (
  local root
  root="`rails_root`"
  [ -n "$root" ] || root=.
  if [ "$root/config/amazon_s3.yml" -nt "$root/tmp/s3cfg" ] || [ -f "$root/config/amazon_s3.yml" -a ! -f "$root/tmp/s3cfg" ]; then
    ruby -ryaml -e '
    c = YAML.load(File.read(ARGV.first))[ENV["RAILS_ENV"]||"development"]
    File.open(ARGV.last,"w") do |f|
    f.puts "access_key = #{c["access_key_id"]}"
    f.puts "secret_key = #{c["secret_access_key"]}"
    end if c.kind_of?(Hash)
    ' "$root/config/amazon_s3.yml" "$root/tmp/s3cfg"
  fi
  if [ -f "$root/tmp/s3cfg" ]; then
    exec s3cmd -c "$root/tmp/s3cfg" "$@"
  else
    exec s3cmd "$@"
  fi
  )
}

script_rails() {
  if [ -f "`rails_root`/script/rails" ]; then
    "`rails_root`/script/rails" "$@"
  else
    local name
    name="$1"
    shift
    "`rails_root`/script/$name" "$@"
  fi
}

twiki () {
  rake db:migrate && rake db:migrate:redo && rake db:test:prepare
}

# git_prompt_info accepts 0 or 1 arguments (i.e., format string)
# returns text to add to bash PS1 prompt (includes branch name)
git_prompt_info () {
  local g="$(git rev-parse --git-dir 2>/dev/null)"
  if [ -n "$g" ]; then
    local r
    local b
    local d
    local s
    # Rebasing
    if [ -d "$g/rebase-apply" ] ; then
      if test -f "$g/rebase-apply/rebasing" ; then
        r="|REBASE"
      fi
      b="$(git symbolic-ref HEAD 2>/dev/null)"
    # Interactive rebase
    elif [ -f "$g/rebase-merge/interactive" ] ; then
      r="|REBASE-i"
      b="$(cat "$g/rebase-merge/head-name")"
    # Merging
    elif [ -f "$g/MERGE_HEAD" ] ; then
      r="|MERGING"
      b="$(git symbolic-ref HEAD 2>/dev/null)"
    else
      if [ -f "$g/BISECT_LOG" ] ; then
        r="|BISECTING"
      fi
      if ! b="$(git symbolic-ref HEAD 2>/dev/null)" ; then
        if ! b="$(git describe --exact-match HEAD 2>/dev/null)" ; then
          b="$(cut -c1-7 "$g/HEAD")..."
        fi
      fi
    fi

    # Dirty Branch
    local newfile='?? '
    if [ -n "$ZSH_VERSION" ]; then
      newfile='\?\? '
    fi
    d=''
    s=$(git status --porcelain 2> /dev/null)
    [[ $s =~ "$newfile" ]] && d+='+'
    [[ $s =~ "M " ]] && d+='*'
    [[ $s =~ "D " ]] && d+='-'

    if [ -n "${1-}" ]; then
      printf "$1" "${b##refs/heads/}$r$d"
    else
      printf "(%s) " "${b##refs/heads/}$r$d"
    fi
  fi
}
